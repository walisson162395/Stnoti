if not game:IsLoaded() then game.Loaded:Wait() end
repeat task.wait() until game:GetService("Players").LocalPlayer

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Player = Players.LocalPlayer

-- CONFIG
local SCAN_DURATION = 0.7
local SCAN_INTERVAL = 0.1
local MAX_HOP_ATTEMPTS = 99999
local API_URL_ADD = "https://mono-webjoin.up.railway.app/add-server"
local API_URL_GET = "http://127.0.0.1:3001"
local PLACE_ID = game.PlaceId

-- LOGGING
local function log(level, msg)
    print(string.format("[%s][%s] %s", os.date("%H:%M:%S"), string.upper(level), msg))
end

-- PARSE GENERATION
local function parseGeneration(genStr)
    if not genStr then return 0 end
    genStr = string.gsub(genStr, "[%$,/s]", "")
    genStr = string.upper(genStr)
    local number, suffix = string.match(genStr, "([%d%.]+)([KMB]?)")
    number = tonumber(number) or 0
    if suffix=="K" then number*=1e3
    elseif suffix=="M" then number*=1e6
    elseif suffix=="B" then number*=1e9 end
    return number
end

local function determineTier(value)
    if value >= 1e7 and value < 5e7 then return "10m"
    elseif value >= 5e7 and value < 1e8 then return "50m"
    elseif value >= 1e8 and value < 3e8 then return "100m"
    elseif value >= 3e8 then return "300m"
    else return nil end
end

-- ENV√çO A API - FUNCI√ìN QUE FUNCIONA
local function SendToAPI(data)
    local req = http_request or request or (syn and syn.request) or (fluxus and fluxus.request)
    if not req then return end
    local body = HttpService:JSONEncode(data)
    req({
        Url = API_URL_ADD,
        Method = "POST",
        Headers = { ["Content-Type"]="application/json" },
        Body = body
    })
    print("[SCANNER] Enviado a API con "..#data.brainrots.." brainrots y "..data.players.." players")
end

-- ESCANEO
local function scanPlots()
    log("info","üîç Escaneando plots...")
    local startTime = tick()
    local sent = {}
    local allBrainrots = {}

    while tick()-startTime < SCAN_DURATION do
        local plots = Workspace:FindFirstChild("Plots")
        if plots then
            for _,desc in ipairs(plots:GetDescendants()) do
                if desc.Name=="AnimalOverhead" then
                    local display = desc:FindFirstChild("DisplayName")
                    local generation = desc:FindFirstChild("Generation")
                    if display and generation and display:IsA("TextLabel") and generation:IsA("TextLabel") then
                        local name = display.Text~="" and display.Text or display.ContentText
                        local gen = generation.Text~="" and generation.Text or generation.ContentText
                        if name and gen and gen:find("/s") then
                            local key = name.."_"..gen
                            if not sent[key] then
                                sent[key]=true
                                local value = parseGeneration(gen)
                                local tier = determineTier(value)
                                if tier then
                                    table.insert(allBrainrots, {tier=tier, name=name, gen=gen, value=value})
                                end
                            end
                        end
                    end
                end
            end
        end
        task.wait(SCAN_INTERVAL)
    end

    if #allBrainrots > 0 then
        SendToAPI({
            jobId = game.JobId,
            players = #Players:GetPlayers(),
            brainrots = allBrainrots,
            timestamp = os.time()
        })
    else
        log("info","‚ö†Ô∏è No se detectaron brainrots que enviar")
    end
end

-- OBTENER SIGUIENTE SERVIDOR
local function GetNextServer()
    local req = http_request or request or (syn and syn.request) or (fluxus and fluxus.request)
    if not req then 
        log("error", "No http_request disponible")
        return nil 
    end
    
    local ok, resp = pcall(function()
        return req({
            Url = API_URL_GET .. "/next",
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode({
                placeId = PLACE_ID,
                currentJob = game.JobId
            }),
            Timeout = 5
        })
    end)
    
    if ok and resp and resp.Body then
        local ok2, data = pcall(function() 
            return HttpService:JSONDecode(resp.Body) 
        end)
        if ok2 and data and data.ok and data.id then 
            return data.id 
        end
    end
    return nil
end

-- SERVER HOP
local attempt = 0
local function Teleport_To_Server()
    attempt = attempt + 1
    if attempt > MAX_HOP_ATTEMPTS then
        log("error","‚ùå M√°ximo de intentos de server hop alcanzado.")
        return
    end
    log("info","üåç Buscando nuevo servidor... (Intento "..attempt..")")
    local jobId = GetNextServer()
    if jobId then
        log("info","üöÄ Teletransportando al JobID: "..jobId)
        local ok, err = pcall(function()
            TeleportService:TeleportToPlaceInstance(PLACE_ID, jobId, Player)
        end)
        if not ok then
            warn("[Error Teleport]: "..tostring(err))
            task.wait(0.6)
            Teleport_To_Server()
        end
    else
        warn("‚ùå No se pudo obtener JobID, reintentando...")
        task.wait(0.5)
        Teleport_To_Server()
    end
end

TeleportService.TeleportInitFailed:Connect(function()
    warn("‚ö†Ô∏è Teleport fallido, reintentando...")
    task.wait(0.3)
    Teleport_To_Server()
end)

-- MAIN
local function main()
    log("info","üöÄ Hopper iniciado")
    task.wait(0.1)
    scanPlots()
    log("info","‚úÖ Scan completado, hopeando...")
    Teleport_To_Server()
end

main()
