if not game:IsLoaded() then game.Loaded:Wait() end
repeat task.wait() until game:GetService("Players").LocalPlayer

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Player = Players.LocalPlayer

-- CONFIG
local SCAN_DURATION = 3        -- duraci√≥n del escaneo en segundos
local SCAN_INTERVAL = 0.1      -- cada cu√°nto revisar los plots
local MAX_HOP_ATTEMPTS = 9999  -- m√°ximo de intentos de server hop
local API_URL_ADD = "https://webhooks-production-f2d6.up.railway.app/add-server"
local API_URL_GET = "https://web-production-219c3.up.railway.app/get"
local PLACE_ID = game.PlaceId   -- ID del juego actual

-- LOGGING
local function log(level, msg)
    print(string.format("[%s][%s] %s", os.date("%H:%M:%S"), string.upper(level), msg))
end

-- PARSE GENERATION
local function parseGeneration(genStr)
    if not genStr then return 0 end
    genStr = string.gsub(genStr, "[%$,/s]", "")
    genStr = string.upper(genStr)
    local number, suffix = string.match(genStr, "([%d%.]+)([KMB]?)")
    number = tonumber(number) or 0
    if suffix=="K" then number*=1e3
    elseif suffix=="M" then number*=1e6
    elseif suffix=="B" then number*=1e9 end
    return number
end

local function determineTier(value)
    if value >= 1e7 and value < 5e7 then return "10m"
    elseif value >= 5e7 and value < 1e8 then return "50m"
    elseif value >= 1e8 and value < 3e8 then return "100m"
    elseif value >= 3e8 then return "300m"
    else return nil end
end

-- ENV√çO A API
local function SendToAPI(data)
    local req = http_request or request or (syn and syn.request) or (fluxus and fluxus.request)
    if not req then return end
    local body = HttpService:JSONEncode(data)
    req({
        Url = API_URL_ADD,
        Method = "POST",
        Headers = { ["Content-Type"]="application/json" },
        Body = body
    })
    print("[SCANNER] Enviado a API con "..#data.brainrots.." brainrots y "..data.players.." players")
end

-- ESCANEO
local function scanPlots()
    log("info","üîç Escaneando plots...")
    local startTime = tick()
    local sent = {}
    local allBrainrots = {}

    while tick()-startTime < SCAN_DURATION do
        local plots = Workspace:FindFirstChild("Plots")
        if plots then
            -- Optimizaci√≥n B: solo buscar AnimalOverhead
            for _,desc in ipairs(plots:GetDescendants()) do
                if desc.Name=="AnimalOverhead" then
                    local display = desc:FindFirstChild("DisplayName")
                    local generation = desc:FindFirstChild("Generation")
                    if display and generation and display:IsA("TextLabel") and generation:IsA("TextLabel") then
                        local name = display.Text~="" and display.Text or display.ContentText
                        local gen = generation.Text~="" and generation.Text or generation.ContentText
                        if name and gen and gen:find("/s") then
                            local key = name.."_"..gen
                            if not sent[key] then
                                sent[key]=true
                                local value = parseGeneration(gen)
                                local tier = determineTier(value)
                                if tier then
                                    table.insert(allBrainrots, {tier=tier, name=name, gen=gen, value=value})
                                end
                            end
                        end
                    end
                end
            end
        end
        task.wait(SCAN_INTERVAL)
    end

    if #allBrainrots > 0 then
        SendToAPI({
            jobId = game.JobId,
            players = #Players:GetPlayers(),
            brainrots = allBrainrots,
            timestamp = os.time()
        })
    else
        log("info","‚ö†Ô∏è No se detectaron brainrots que enviar")
    end
end

-- SERVER HOP
local attempt = 0
local function GetJobId()
    local req = http_request or request or (syn and syn.request) or (fluxus and fluxus.request)
    if not req then return nil end
    local resp = req({Url = API_URL_GET, Method = "GET"})
    if resp and resp.Body then
        local ok, data = pcall(function() return HttpService:JSONDecode(resp.Body) end)
        if ok and data and data.job_id then return data.job_id end
    end
    return nil
end

local function Teleport_To_Server()
    attempt += 1
    if attempt > MAX_HOP_ATTEMPTS then
        log("error","‚ùå M√°ximo de intentos de server hop alcanzado.")
        return
    end
    log("info","üåç Buscando nuevo servidor... (Intento "..attempt..")")
    local jobId = GetJobId()
    if jobId then
        log("info","üöÄ Teletransportando al JobID: "..jobId)
        local ok, err = pcall(function()
            TeleportService:TeleportToPlaceInstance(PLACE_ID, jobId, Player)
        end)
        if not ok then
            warn("[Error Teleport]: "..tostring(err))
            task.wait(0.3)
            Teleport_To_Server()
        end
    else
        warn("‚ùå No se pudo obtener JobID, reintentando...")
        task.wait(2)
        Teleport_To_Server()
    end
end

TeleportService.TeleportInitFailed:Connect(function()
    warn("‚ö†Ô∏è Teleport fallido, reintentando...")
    task.wait(1)
    Teleport_To_Server()
end)

-- MAIN
local function main()
    log("info","‚åõ Esperando 1 segundos antes del escaneo...")
    task.wait(1)
    scanPlots()
    log("info","üïí Escaneo terminado, iniciando server hop...")
    Teleport_To_Server()
end

main()
